### vue 简介

尤雨溪

参考文档：vue 官网

渐进式：类似于迭代开发，vue.js 只是一些核心代码，可以让你搭建基本页面如果你的页面功能相对比较丰富，那么需要相关的一些插件去完成。

插件：就是一些功能代码模块。它是为了给已经完成的功能代码额外去添加功能用的。

官方插件：vuex， vue-router。。。官方出品的，都是 vue 官方的插件

第三方插件：也是为了给 vue 去添加功能用的，但是是别人写的。如：axios

数据为尊，动态显示页面

### 项目接口地址

域名和端口号写在：vue.config.js中的

后台管理系统：

PC端前台：

### 四种循环

1.  for

    - 最基本的循环
    - 用来专门遍历数组的
    - 可以使用 break 和 continue

2.  for in 可以用 Object.keys().forEach 来提高效率

    - 专门用来遍历对象的属性的，这个属性能遍历到还是遍历不到，要看这个属性是不是可枚举的。(注意，原型当中的属性是不可枚举的，但是 for in 还是遍历了)
    - for in 效率最低，因为除了遍历自身以外，还要遍历原型

3.  for of(用得不多)

    - 专门遍历可迭代的数据(Symbol.iterator)
    - ...argus(扩展运算符)
    - 数组有迭代器方法，对象没有
    - 还可以遍历 map 和 set

4.  forEach
    - 是一个数组的方法，效率极高
    - 但是不能使用 break 和 continue

举例：

```js
let obj = {
  name: "zly",
  age: 18,
};

// 用for in
for (let key in obj) {
  console.log(key.obj[key]);
}

// 用forEach
Object.keys(obj).forEach((item) => {
  console.log(item);
  console.log(item);
  console.log(obj.name);
  console.log(obj.age);
});
```

###  模块、模块化、组件、组件化
模块：一个js文件。
模块化：多个js文件组成的开发。
组件：一个按功能包含html, css, js的文件。
组件化：多个组件组成的开发。

6. App.vue组件：相当于所有组件的父组件。

7. 页面交互分为：静态页面实现 和 动态交互实现

8. 静态页面实现
  - 1. 拆分组件：拆分页面，定义组件，最大化重用(html,css,图片)
  - 2. 组装组件：就是把各个组件组装起来放在App.vue里面
  - 3. 渲染组件：就是把组件拼装完后，不考虑数据，先展示出来

  注意：自定义脚手架中：webpack配置拷贝public下的css文件："npm install copy-webpack-plugin@5.1.1"

9. 动态交互实现
  1. 初始化数据动态显示

    初始化数据分析：
      数据类型：一般我们的数据最终都是放在一个数组内部，数组内部放对象
      数据名称：comments: [{},{},{}]
      定义在哪个组件：(看哪个组件还是哪些个组件使用到)
        - 数据用到不是说展示就代表用到，而是说数据的增删改查都叫用到数据
        - 如果这个数据只是某一个组件用到，那么数据就在这一个组件当中定义
        - 如果这个数据在某些个组件当中用到，那么久找这些个共同的祖先组件去定义
    
    组件标签名和属性名大小写问题：
      基本规则：要么原样去写，要么转小写中间用-连接
      如：AddComment <AddComment/> 或者<add-comment>

  2. 交互(与用户的交互)

    对于数据的操作：
      数据在哪，操作数据的方法就要在哪定义，而不是随便的在某一个组件当中去操作数据，想要操作数据的组件，可以通过调用操作数据的方法，间接去操作数据。
    添加和删除：
      子组件添加事件和事件回调，事件回调当中去调用外部操作数据的方法，数据所在的组件去添加操作数据的方法

10. vm 和 组件对象的关系
  - vm 实例化对象的原型的原型
  - $on、$emit等方法是在vm的隐式原型身上的(Vue的显示原型身上)
  - vm原型对象就是组件对象的原型对象的原型对象


### 为什么要使用cookie
因为http请求无状态，服务器没法分别上一次和这一次的请求是不是同一个人
为何cookie后面用得少？
1. 因为是明文(不安全)
2. 内存空间小，能存的东西少。
cookie是什么端的技术？是浏览器端(前端)的技术，cookie是存储在前端浏览器中的东西，跟后端没关系。
然后，状态保持出现了：session
什么是session？
- session是服务器端的技术，可以存储在服务器的MySQL当中。
session由三部分组成：
    1. session-key(就是前端说的sessionId)
    2. session-value
    3. expire-time

具体操作：
  1. 客户端第一次发登录请求的时候，那我根据你的用户名和密码在后端的一张表当中，创建一个session存储起来。
  2. 接着服务器端会把session里面的session-key的值(sessionId)通过cookie给你传过来，前端人员要把这个放在cookie里面。(那么这个session-key就存储在浏览器的cookie当中了)
  3. 这个时候前端牛逼了，每一次发请求的时候都把第一次发请求所带过来的session-key的值通过cookie带上，这样的话，服务器每一次接收到你发过来的session-key的时候，他就会从session-key的那种表里面匹配和你的发过来的session-key对应。只要找到了他就会拿session-value所对应的用户信息返回给前端。

为什么要使用cookie和session？
主要是为了做状态保持。

token 可以做单点登录(多端登录)。好几个地方登录同一个账号。
token和session的区别：
  - token 不依赖cookie。token 返回去给前端的时候，前端只需要在头部(request-header)当中设置一个标识叫token然后等于这个返回来的token串，就行了。
  - session 在传递的时候是需要通过cookie传递的。


localStorage是H5当中的一个存储技术，它相当于浏览器端的一个小型数据库。在浏览器中按f12，然后在Application -> Storage 中可以查看。
存储到localStorage当中的东西，都会自动转化为字符串
localStorage当中有四个API
1. localStorage..setItem('键', 值); // 给localStorage存储数据，键名一般都写大写
2. localStorage.getItem('键'); // 获取localStorage当中的某个键数据
3. localStorage.removeItem('键'); // 删除localStorage当中某个数据
4. localStorage.clear(); // 清空localStorage所有的数据

### 类型转换
什么时候会发生类型转换？
1. 计算的时候。全部转基本类型。
2. 比较的时候。全部转基本类型。
3. 判等的时候。判等如果都是对象，判断地址。如果有一个不是对象类型，那就转基本类型。
```js
1. console.log([1,2,3] + 100); // 1,2,3100
2. console.log({name:'zly'} + 100); // [object Object]100
function fn() {
  consoel.log(111);
}
3. console.log(fn + 100); // 结果是函数代码 + 100，都是字符串
```

对象数据类型转基本数据类型：
1. 数组转基本：去掉中括号，中间留下啥，就带引号。(空数组是空字符串。)
2. 对象转基本：固定的字符串类型的[object Object]
3. 函数转基本：固定的函数整体加字符串


### 一般监视和深度监视
一般监视：监视的是数组的数据，但是数组内部的对象的数据监视不到。
深度监视(deep: true)：可以监视到数组本身的数据，也可以监视到数组内部对象的数据