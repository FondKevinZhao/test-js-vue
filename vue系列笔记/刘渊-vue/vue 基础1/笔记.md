### vue 简介

尤雨溪

参考文档：vue 官网

渐进式：类似于迭代开发，vue.js 只是一些核心代码，可以让你搭建基本页面如果你的页面功能相对比较丰富，那么需要相关的一些插件去完成。

插件：就是一些功能代码模块。它是为了给已经完成的功能代码额外去添加功能用的。

官方插件：vuex， vue-router。。。官方出品的，都是 vue 官方的插件

第三方插件：也是为了给 vue 去添加功能用的，但是是别人写的。如：axios

数据为尊，动态显示页面

### 项目接口地址

域名和端口号写在：vue.config.js中的

后台管理系统：

PC端前台：

### 四种循环

1.  for

    - 最基本的循环
    - 用来专门遍历数组的
    - 可以使用 break 和 continue

2.  for in 可以用 Object.keys().forEach 来提高效率

    - 专门用来遍历对象的属性的，这个属性能遍历到还是遍历不到，要看这个属性是不是可枚举的。(注意，原型当中的属性是不可枚举的，但是 for in 还是遍历了)
    - for in 效率最低，因为除了遍历自身以外，还要遍历原型

3.  for of(用得不多)

    - 专门遍历可迭代的数据(Symbol.iterator)
    - ...argus(扩展运算符)
    - 数组有迭代器方法，对象没有
    - 还可以遍历 map 和 set

4.  forEach
    - 是一个数组的方法，效率极高
    - 但是不能使用 break 和 continue

举例：

```js
let obj = {
  name: "zly",
  age: 18,
};

// 用for in
for (let key in obj) {
  console.log(key.obj[key]);
}

// 用forEach
Object.keys(obj).forEach((item) => {
  console.log(item);
  console.log(item);
  console.log(obj.name);
  console.log(obj.age);
});
```

###  模块、模块化、组件、组件化
模块：一个js文件。
模块化：多个js文件组成的开发。
组件：一个按功能包含html, css, js的文件。
组件化：多个组件组成的开发。

6. App.vue组件：相当于所有组件的父组件。

7. 页面交互分为：静态页面实现 和 动态交互实现

8. 静态页面实现
  - 1. 拆分组件：拆分页面，定义组件，最大化重用(html,css,图片)
  - 2. 组装组件：就是把各个组件组装起来放在App.vue里面
  - 3. 渲染组件：就是把组件拼装完后，不考虑数据，先展示出来

  注意：自定义脚手架中：webpack配置拷贝public下的css文件："npm install copy-webpack-plugin@5.1.1"

9. 动态交互实现
  1. 初始化数据动态显示

    初始化数据分析：
      数据类型：一般我们的数据最终都是放在一个数组内部，数组内部放对象
      数据名称：comments: [{},{},{}]
      定义在哪个组件：(看哪个组件还是哪些个组件使用到)
        - 数据用到不是说展示就代表用到，而是说数据的增删改查都叫用到数据
        - 如果这个数据只是某一个组件用到，那么数据就在这一个组件当中定义
        - 如果这个数据在某些个组件当中用到，那么久找这些个共同的祖先组件去定义
    
    组件标签名和属性名大小写问题：
      基本规则：要么原样去写，要么转小写中间用-连接
      如：AddComment <AddComment/> 或者<add-comment>

  2. 交互(与用户的交互)

    对于数据的操作：
      数据在哪，操作数据的方法就要在哪定义，而不是随便的在某一个组件当中去操作数据，想要操作数据的组件，可以通过调用操作数据的方法，间接去操作数据。
    添加和删除：
      子组件添加事件和事件回调，事件回调当中去调用外部操作数据的方法，数据所在的组件去添加操作数据的方法

10. vm 和 组件对象的关系
  - vm 实例化对象的原型的原型
  - $on、$emit等方法是在vm的隐式原型身上的(Vue的显示原型身上)
  - vm原型对象就是组件对象的原型对象的原型对象


### 为什么要使用cookie
因为http请求无状态，服务器没法分别上一次和这一次的请求是不是同一个人
为何cookie后面用得少？
1. 因为是明文(不安全)
2. 内存空间小，能存的东西少。
cookie是什么端的技术？是浏览器端(前端)的技术，cookie是存储在前端浏览器中的东西，跟后端没关系。
然后，状态保持出现了：session
什么是session？
- session是服务器端的技术，可以存储在服务器的MySQL当中。
session由三部分组成：
    1. session-key(就是前端说的sessionId)
    2. session-value
    3. expire-time

具体操作：
  1. 客户端第一次发登录请求的时候，那我根据你的用户名和密码在后端的一张表当中，创建一个session存储起来。
  2. 接着服务器端会把session里面的session-key的值(sessionId)通过cookie给你传过来，前端人员要把这个放在cookie里面。(那么这个session-key就存储在浏览器的cookie当中了)
  3. 这个时候前端牛逼了，每一次发请求的时候都把第一次发请求所带过来的session-key的值通过cookie带上，这样的话，服务器每一次接收到你发过来的session-key的时候，他就会从session-key的那种表里面匹配和你的发过来的session-key对应。只要找到了他就会拿session-value所对应的用户信息返回给前端。

为什么要使用cookie和session？
主要是为了做状态保持。

token 可以做单点登录(多端登录)。好几个地方登录同一个账号。
token和session的区别：
  - token 不依赖cookie。token 返回去给前端的时候，前端只需要在头部(request-header)当中设置一个标识叫token然后等于这个返回来的token串，就行了。
  - session 在传递的时候是需要通过cookie传递的。


localStorage是H5当中的一个存储技术，它相当于浏览器端的一个小型数据库。在浏览器中按f12，然后在Application -> Storage 中可以查看。
存储到localStorage当中的东西，都会自动转化为字符串
localStorage当中有四个API
1. localStorage..setItem('键', 值); // 给localStorage存储数据，键名一般都写大写
2. localStorage.getItem('键'); // 获取localStorage当中的某个键数据
3. localStorage.removeItem('键'); // 删除localStorage当中某个数据
4. localStorage.clear(); // 清空localStorage所有的数据

### 类型转换
什么时候会发生类型转换？
1. 计算的时候。全部转基本类型。
2. 比较的时候。全部转基本类型。
3. 判等的时候。判等如果都是对象，判断地址。如果有一个不是对象类型，那就转基本类型。
```js
1. console.log([1,2,3] + 100); // 1,2,3100
2. console.log({name:'zly'} + 100); // [object Object]100
function fn() {
  consoel.log(111);
}
3. console.log(fn + 100); // 结果是函数代码 + 100，都是字符串
```

对象数据类型转基本数据类型：
1. 数组转基本：去掉中括号，中间留下啥，就带引号。(空数组是空字符串。)
2. 对象转基本：固定的字符串类型的[object Object]
3. 函数转基本：固定的函数整体加字符串


### 一般监视和深度监视
一般监视：监视的是数组的数据，但是数组内部的对象的数据监视不到。
深度监视(deep: true)：可以监视到数组本身的数据，也可以监视到数组内部对象的数据


### 跨域
- 跨域：存在于浏览器上的同源策略验证。
- 特点：
  1. 跨域只存在于浏览器。
  2. 不在浏览器发请求时不会存在跨域问题的。
  3. http请求分为两大类：普通http请求和Ajax请求(跨域是出现在Ajax请求)
  普通http请求和Ajax请求的区别：
    - 普通请求一般只有get(get其实对应的就是a标签和地址栏输入回车)和post(post其实对应的就是form表单)。普通请求的特点：1. 页面会刷新。2. 不会跨域。
    - Ajax请求一般对应的：get post delete put。特点：1. 几乎都是异步发送的。2. 页面不刷新，局部更新。

- 在什么地方会有跨域：
  1. 浏览器给服务器发请求会跨域。
  2. 服务器给服务器发请求不会跨域。

- 什么条件会跨域
  1. 同源(协议 ip 端口一致)不跨域。
  2. 不同源就跨域(三个中间有一个不一样就会跨域)。

- 解决跨域：前端可以解决、后端也可以解决。一般后端解决比前端解决容易。
  1. jsonp(只能解决get请求，并且需要后端配合，所以根本不用),。
  2. cors(需要后端配合)。博客地址：https://blog.csdn.net/qq_41635401/article/details/121266740
  3. 前端配置代理服务器。
  4. nginx反向代理。思路是：利用nginx反向代理把跨域为不跨域，支持各种请求方式。缺点：需要在nginx进行额外配置，语义不清晰。
  后端解决跨域：如果是Java直接在下一个包，然后写两行代码就解决了。

### 配置代理服务器解决跨域
1. 本身我们现在就跑在开发服务器 webpack-dev-server，而这个服务器带了一个模块，这个模块可以支持我们使用代理。
2. 原理：
  - 在浏览器发请求的时候，把这个请求发给服务器上的这个代理模块。
  - 再由这个代理模块转发给我们真正的服务器。
  - 这样的话，我们原来由浏览器直接发送请求到服务器就转化为服务器到服务器之间的请求。
3. 你要让代理转发，那么得告诉代理你的这个请求什么情况需要转发
  - 配置以固定什么开头的路径需要代理转发，代理看到这个路径是以它开头就会帮你转发。
4. 代理转发的时候会把路径交给真正的请求服务器，作为请求路径，需要把固定的开头去除。
5. changeOrigin: true, // 支持跨域，如果协议/主机也不相同，必须加上


### 路由
什么是路由？路径和某个东西的映射关系。
路由分为：前端路由和后端路由。
  1. 这个东西可以是函数，也可以是组件。
  2. 如果这个东西是函数，那是后端路由。
  3. 如果这个东西是组件，那是前端路由。

