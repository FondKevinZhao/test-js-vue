<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <!-- 
    原型 prototype：
      - JS中所有的函数都有一个prototype属性，且只有函数才有
      - 其所有属性和方法，都能被构造函数的实例对象共享访问

    构造器 constructor：
      - JS中constructor存在于每一个函数的prototype属性中，其保存了指向该函数的一个引用

    原型链 __proto__：
      - JS中对象都有一个内置属性，即 __proto__ (隐式原型链属性)，一般情况下它指向创建它的构造函数的prototype属性。另外函数比较特殊，它也有此属性。
      - 当js引擎查找对象的某个属性时，先查找对象本身是否存在该属性，如果不存在，就会在原型链上一层一层往上查找。
   -->
  <script>
    // 1. 如何准且判断一个变量是数组类型
    // 博客地址：https://blog.csdn.net/weixin_44447255/article/details/120447130
    /* var arr = [1, 2, 3];
    // 方法一：
    console.log(arr instanceof Array);
    // 方法二：
    var res = Object.prototype.toString.call(arr).slice(8, -1).toLowerCase();
    console.log(res);
    // 方法三：
    var res = Array.isArray(arr);
    console.log(res);
    // 方法四：
    var res = arr.constructor === Array;
    console.log(res); */



    // 2. 下面代码分别输出什么？
    // 博客：https://www.cnblogs.com/shuiyi/p/5343399.html
    // 博客：https://www.cnblogs.com/wang-jiang/p/4189507.html
    /* console.log('Objcet：', Object instanceof Function);
    console.log('Function：', Function instanceof Object); */



    // 3. 
    function A(name) {
      this.name = name;
    }
    A.prototype.getName = function () {
      console.log(this.name);
    }
    let a1 = newA('a1');
    let a2 = newA('a2');
    a1.getName();
    a2.getName();
    delete A.prototype.getName;
    a1.getName();
    a2.getName();
  </script>
</body>

</html>